## 0. 스택1

----

1. 스택

2. 재귀호출

3. Memoization

4. DP

5. DFS

## 1. 스택1

----

1. 스택의 특성
   
   * 자료를 쌓아 올린 형태의 자료구조
   
   * 스택에 저장된 자료 -> 선형 구조
     
     * 선형 구조: 자료 간의 관계가 1대 1의 관계
     
     * 비선형 구조: 자료 간의 관계가 1대 N의 관계 (ex.트리)
   
   * 스택에 자료를 삽입하거나 꺼낼 수 있다.
   
   * 후입선출(LIFO, Last-In-First-Out)

2. 스택의 구현
   
   * 스택을 프로그램에서 구현하기 위해서 필요한 자료구조와 연산
   
   * 자료구조: 자료를 선형으로 저장할 저장소
     
     * 배열을 사용할 수 있다.
     
     * 저장소 자체를 스택이라 부르기도 한다.
     
     * 스택에서 마지막 삽입된 원소의 위치를 top이라 부른다.
   
   * 연산
     
     * 삽입: 저장소에 자료 저장. 보통 push라고 부름
     
     * 삭제: 저장소에서 자료를 꺼냄. 삽입한 자료의 역순으로 꺼냄. 보통 pop이라 부름
     
     * 스택이 공백인지 아닌지를 확인하는 연산: isEmpty
     
     * 스택의 top에 있는 item(원소)을 반환하는 연산: peek
   
   * 스택의 삽입/삭제 과정
   
   * 스택의 push 알고리즘
     
     * append 메소드를 통해 리스트의 마지막에 데이터를 삽입
   
   * 스택의 pop 알고리즘

3. 연습문제1: 스택 구현
   
   ```python
   # 스택을 클래스로 구현
   class stack:
       def __init__(self):
           self.items = []  # 스택에 사용할 리스트 (저장공간)
           # self.top = -1
           # self.size = 10
   
       # 1. push 원소 삽입
       # item: 삽입할 원소
       def push(self, item):
           self.items.append(item)
           # self.top += 1
           print(f"push {item}")
   
       # 2. pop 원소 제거 (꺼내기)
       def pop(self):
           item = self.items.pop(-1)
           print(f"pop {item}")
           return item
   
       # 3. peek top에 있는 원소 반환(제거X)
       def peek(self):
           print(f"peek {self.items[-1]}")
           return self.items[-1]
   
       # 4. isEmpty 스택이 비어있는지 확인하는 연산, 비어있으면 True
       def isEmpty(self):
           return not self.items
   ```

4. 스택 구현 고려 사항
   
   * 1차원 배열을 사용하여 구현할 경우
     
     * 구현 용이 but, 스택의 크기 변경 어렵다
   
   * 이를 해결하기 위한 방법 -> 저장소를 동적으로 할당하여 스택을 구현하는 방법
     
     * 동적 연결리스트를 이용하여 구현하는 방법 의미
     
     * 구현 복잡 but, 메모리를 효율적으로 사용

5. 스택의 응용1: 괄호검사
   
   * 괄호의 종류 : 대괄호([]), 중괄호({}), 소괄호(())
   
   * 조건
     
     * 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 함
     
     * 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 함
     
     * 괄호 사이에는 포함 관계만 존재
   
   * 잘못된 괄호 사용의 예
   
   * 괄호를 조사하는 알고리즘 개요
     
     * 문자열에 있는 괄호를 차례대로 조사 - 왼쪽 괄호를 만나면 -> 스택에 삽입, 오른쪽 괄호를 만나면 -> 스택에서 top 괄호를 삭제한 후 짝이 맞는지 검사
     
     * 이때, 스택이 비어 있으면 조건 1또는 2에 위배, 괄호의 짝이 맞지 않으면 조건 3에 위배
     
     * 마지막 괄호까지 조사 후에도 스택에 괄호가 남아 있으면 -> 조건 1에 위배

6. 연습문제2: 괄호의 짝 검사
   
   ```python
   def find_pair(texts):
       stack = []
   
       for text in texts:
           if text == "(":  # 여는 괄호라면
               stack.append(text)
           else:  # 닫는 괄호라면
               # 길이 0이면 꺼낼 수 없는 상태
               if len(stack) == 0:
                   return 0
               else:
                   before = stack.pop(-1)  # 마지막 꺼내기
                   if before != "(":  # 여는 괄호가 아니면
                       return 0
   
       if len(stack) == 0:
           return 1
       else:
           return 0
   ```

7. 스택의 응용2: function call
   
   * 프로그램에서 함수 호출과 복귀에 따른 수행 순서 관리
     
     * 가장 마지막에 호출된 함수 - 가장 먼저 실행 완료, 복귀 -> 후입선출 구조
     
     * 함수 호출 발생 - 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보 -> 스택 프레임(stack frame)에 저장하여 시스템 스택에 삽입
     
     * 함수 실행 끝 - 시스템 스택의 top 원소(스택 프레임)를 삭제(pop)하면서 프레임에 저장되어 있던 복귀주소를 확인하고 복귀
     
     * 함수 호출과 복귀에 따라 이 과정을 반복 - 전체 프로그램 수행 종료 -> 시스템 스택은 공백 스택이 됨

## 2. 재귀호출

---

1. 재귀호출
   
   * 자기 자신을 호출하여 순환 수행되는 것
   
   * 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성
   
   * 피보나치
     
     * 0과 1로 시작하고, 이전의 두 수 합을 다음 항으로 하는 수열
     
     * 피보나치 수열의 i번째 값을 계산하는 함수 F를 정의하면 다음과 같다.
       
       * F0 = 0, F1 = 1
       
       * Fi = Fi-1 + Fi-2  for i>=2
      ```python
     def fibo2(n):
     	if n < 2:
	  return n
	else:
	  return fibo2(n-1) + fibo2(n-2)
     ```


## 3. Memoization

----

0. 앞의 피보나치 수를 구하는 함수를 재귀함수로 구현 -> 엄청난 중복 호출 존재

1. 메모이제이션(memoization)
   
   * 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록하여 전체적인 실행속도를 빠르게 하는 기술
     
     * 동적 계획법의 핵심이 되는 기술
   
   * 글자 그대로 해석하면, '메모리에 넣기(to put in memory)'라는 의미
   
   * 피보나치 알고리즘
     
     ```python
     def fibo1(n):
         if n >= 2 and len(memo) <= n:
             memo.append(fibo1(n-1) + fibo1(n-2))
         return memo[n]
     memo = [0, 1]
     ```

## 4. DP(Dynamic Programming)

----

1. 동적 계획(Dynamic Programming) 알고리즘
   
   * 그리디 알고리즘과 같이 **최적화 문제**를 해결하는 알고리즘
   
   * 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제 해결하는 알고리즘

2. 피보나치 수 DP 적용
   
   * 피보나치 수 -> 부분 문제의 답으로부터 본 문제의 답을 얻을 수 있음 -> 최적 부분 구조로 이루어져 있다.
   
   * 접근 방식
     
     * 문제를 부분 문제로 분할
     
     * 가장 작은 부분 문제부터 해 구하기
     
     * 결과는 테이블에 저장하고, 테이블에 저장된 부분 문제의 해를 이용하여 상위 문제의 해 구하기
   
   * 알고리즘
     ```python
     def fibo2(n):
       f = [0, 1]
       for i in range(2, n+1):
         f.append(f[i-1] + f[i-2])
       return f[n]
     ```

3. DP의 구현 방식
   
   * recursive 방식: fibo1
   
   * iterative 방식: fibo2
   
   * memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 성능 면에서 보다 효율적
   
   * 재귀적 구조 -> 시스템 호출 스택을 사용하는 오버헤드 발생

## 5. DFS(깊이우선탐색)

----

1. 비선형 구조인 그래프 구조 -> 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것 중요
   
   * 두가지 방법
     
     * 깊이 우선 탐색(Depth First Search, DFS)
     
     * 너비 우선 탐색(Breadth First Search, BFS)

2. DFS(깊이우선탐색)
   
   * 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색 - 더 이상 갈 곳이 없게 되면 - 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아감 - 다른 방향의 정점으로 탐색을 계속 반복
   
   * 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색 반복 -> 후입선출 구조의 스택 사용

3. DFS 알고리즘
   
   * 시작 정점 v를 결정하여 방문
   
   * 정점 v에 인접한 정점 중
     
     * 방문하지 않은 정점w가 있으면, 정점v를 스택에 push하고 정점 w 방문 -> 그리고 w를 다음 v로 하여 다시 반복
     
     * 방문하지 않은 정점X -> 탐색의 방향을 바꾸기 위해 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 반복
   
   * 스택이 공백이 될 때 까지 위를 반복
   
   * 구현
     
     ```python
     adjList = [[1, 2],
                [0, 3, 4],
                [0, 4],
                [1, 5],
                [1, 2, 5],
                [3, 4, 6],
                [5]]
     def dfs(v, N):
     
          top = -1
          print(v)    # 방문
     
          # 시작점 방문 표시
          visited[v] = 1
          while True:
              # v의 인접 간선 확인
              for w in adjList[v]:
                  # 방문하지 않았다면
                  if not visited[w]:
                      top += 1        # push
                      stack[top] = v
                      visited[w] = 1  # 방문처리
                      v = w
                      print(v)
                      break
              else:               # w가 없으면
                  # 스택이 비어있지 않으면
                  if top != -1:
                      v = stack[top]  # pop
                      top -= 1
                  else:   # 스택이 비어있으면
                      break
     ```

4. 연습문제 3
   
   ```python
   # s: start
   # V: 정점의 개수
   # 0 1 2 3 4 5 6 7
   adj = [[],
          [2, 3],
          [1, 4, 5],
          [1, 7],
          [2, 6],
          [2, 6],
          [4, 5, 7],
          [3, 6]]
   adm = [[0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 1, 1, 0, 0, 0, 0],
          [0, 1, 0, 0, 1, 1, 0, 0],
          [0, 1, 0, 0, 0, 0, 0, 1],
          [0, 0, 1, 0, 0, 0, 1, 0],
          [0, 0, 1, 0, 0, 0, 1, 0],
          [0, 0, 0, 0, 1, 1, 0, 1],
          [0, 0, 0, 1, 0, 0, 1, 0]]
   
   def dfs(s, V):
       # 정점의 방문 여부를 알기 위한 배열 선언
       visited = [0] * (V + 1)  # 0번 인덱스 사용X
       stack = []   # size xxx
       now = s     # 현재 위치 now로 표현
       visited[now] = 1    # 시작 위치는 방문했다고 체크
       print(f"-{now}", end="")
   
       while True:
           # 다음 방문 위치 방문
           for w in range(1, V+1):  # 1~V번 정점
               # 다음 방문 위치가 있고, 해당 방문위치를 방문한 적이 없으면
               # 다음 방문 위치 처리
               # 현재 위치를 스택에 저장
               # 다음 방문 위치를 방문했다고 체크
               # 현재 위치를 다음 위치로 바꾸고
               # 탈출
               if adm[now][w] and not visited[w]:
                   stack.append(now)
                   visited[w] = 1
                   now = w
                   print(f"-{now}", end="")
                   break
           else:
               # 다음 방문 위치가 없다(방문했던 곳만 남거나, 인접한 곳X)
               if stack:   # 스택이 비어있지 않으면 아직 방문할 곳 존재
                   # 지난 정점으로 돌아가기
                   now = stack.pop()
               else:   # 스택 비어있음 -> 탐색 중지
                   break
       return
   ```
