## 0. 문자열

----

1. 문자열

2. 패턴 매칭

3. 문자열 암호화

4. 문자열 압축

## 1. 문자의 표현

----

1. 컴퓨터에서의 문자표현
   
   * 각 문자에 대해서 대응되는 숫자 - 이것을 메모리에 저장
   
   * 영어 - 대소문자 합쳐서 52 - 6비트면 모두 표현 가능 -> 이를 코드체계라고 함
   
   * 각 지역 별 코드체계 - 네트워크 발전 - 서로 정보를 주고 받을 때 다르게 해석
   
   * 혼동을 피하기 위해 표준안 만듦
   
   * ASCII(American Standard Code for Information Interchange)
     
     * 7bit 인코딩, 128문자 표현, 33개의 출력 불가능한 제어 문자, 공백을 비롯한 95개의 출력 가능한 문자
   
   * 확장 아스키
   
   * 유니코드

## 2. 문자열

----

1. 문자열
   
   * 문자열의 분류
     
     * fixed length
     
     * variable length
       
       * length controlled
       
       * delimited
   
   * java에서 String 클래스에 대한 메모리 배치 예
   
   * c언어에서 문자열 처리
   
   * java에서의 문자열 처리
   
   * python에서의 문자열 처리
     
     * char 타입X
     
     * 텍스트 데이터의 취급방법 통일
     
     * 문자열 기호
       
       * ', ", ''', """
       
       * +연결
       
       * *반복
     
     * 문자열 -> 시퀀스 자료형 -> 인덱싱, 슬라이싱 연산 가능
     
     * 메소드: replace(), split(), isalpha(), find()
     
     * immutable
   
   * C와 Java의 String 처리의 기본적인 차이점

2. 문자열 뒤집기

3. 문자열 비교

4. 문자열 숫자를 정수로 변환하기

## 3. 패턴 매칭

-----

1. 패턴 매칭
   
   * 알고리즘
     
     * 고지식한 패턴 검색 알고리즘
     
     * 카프-라빈 알고리즘
     
     * KMP 알고리즘
     
     * 보이어-무어 알고리즘

2. 고지식한 알고리즘(Brute Force)
   
   * 문자열을 처음부터 끝까지 차례대로 순회, 패턴 내의 문자들을 일일이 비교
   
   * 구현
     
     ```python
     def BruteForce(p, t):
         idx_t, idx_p = 0, 0   # t,p의 인덱스
         while idx_p < len(p) and idx_t < len(t):
             if t[idx_t] != p[idx_p]:
                 idx_t -= idx_p
                 idx_p = -1
             idx_t += 1
             idx_p += 1
         if idx_p == len(p):
             return idx_t - len(p)  # 일치 인덱스
         else:
             return -1
     ```
   
   * 시간 복잡도 : O(MN), 패턴길이N, 문자열M
     
     * 최악의 경우 텍스트의 모든 위치에서 패턴을 비교해야함

3. KMP 알고리즘
   
   * 불일치가 발생한 텍스트 스트링의 앞부분에 어떤 문자가 있는지 미리 알고 있음 -> 불일치 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭 수행
   
   * 패턴을 전처리 -> 배열 next[M] 을 구해서 잘못된 시작 최소화
     
     * next[M] : 불일치 발생했을 경우 이동할 다음 위치
   
   * 시간 복잡도 : O(M+N)
   
   * 아이디어 설명
   
   * 매칭이 실패했을 때 돌아갈 곳을 계산

4. 보이어-무어 알고리즘
   
   * 오른쪽 -> 왼쪽으로 비교
   
   * 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
   
   * 패턴의 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 패턴의 길이만큼
   
   * 오른쪽 끝에 있는 문자가 불일치하고, 이 문자가 패턴 내에 존재할 경우

5. 문자열 매칭 알고리즘 비교
   
   * 문자열 매칭 알고리즘 비교
     
     * 찾고자 하는 문자열 패턴의 길이: m, 총 문자열 길이: n
     
     * 고지식한 패턴 검색 알고리즘 : O(mn)
     
     * 카프-라빈 알고리즘 : 세타(n)
     
     * KMP 알고리즘 : 세타(n)
     
     * 두 알고리즘들의 공통점 : 문자열의 문자를 적어도 한번씩 훑음 -> 최선의 경우에도 옴(n)
     
     * 보이어-무어 알고리즘
       
       * 텍스트 문자를 다 보지 않아도 됨
       
       * 발상의 전환 : 패턴의 오른쪽부터 비교
       
       * 최악의 경우 : 세타(mn)
       
       * 입력에 따라 다르지만, 일반적으로 세타(n)보다 시간이 덜 든다.

## 4. 문자열 암호화

----

1. 시저 암호
